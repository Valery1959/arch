#!/bin/bash

# https://bytefreaks.net/gnulinux/kvm-virtual-machines-backup-and-restoration

SHUTOFF="shut off"
RUNNING="running"

virsh="sudo virsh"
rsync="sudo rsync -a"

run()
{
  echo "Run '$@'"; $@; [ $? -ne 0 ] && { echo "Cannot run '$@'";  exit 1; }
}

has_state()
{
  dstate=$($virsh domstate $1 2>/dev/null)
  [ -z "$dstate" ] && dstate="$SHUTOFF"
  echo $dstate | paste -d " " - -  | grep "$2" > /dev/null
}

get_vm_list()
{
  read line; line=$(echo $line | sed -e 's/,/ /g')

  vmlist=""; errnum=
  for n in $line
  do
    t=${array[n]}; [ -z $t ] && { echo "$n does not exist" 1>&2; errnum=1; }
    vmlist="$vmlist $t"
  done
  [ ! -z $errnum ] && vmlist=; echo $vmlist
}

run_virsh()
{
  a_vname="$1" # VM name
  a_virsh="$2" # action to execute by virsh
  a_check="$3" # VM state to check
  a_print="$4" # VM state to print if VM check failed
  
  if has_state $a_vname "$a_check"; then
    echo "$a_vname is already $a_check"
    return
  fi

  run $virsh $a_virsh $a_vname | awk '!/^$/'

  until has_state $a_vname "$a_check"; do
    echo " $a_vname still $a_print"
    sleep 1
  done
}

run_backup()
{
  src_paths=$($virsh domblklist $1 | tail -n +3 | grep "/var/" | awk '{ print $2 }')

  for p in $src_paths
  do
    [[ ! $p =~ $images_dir ]] && { echo "$p is not on $images_dir"; exit 1 ; }
  done

  dst_zip=$backup_dir/${1}.7z
  tmp_dir=$backup_dir/$1;
  tmp_xml=$tmp_dir/${1}.xml

  run mkdir -p $tmp_dir
  echo "Run 'virsh dumpxml $1 > $tmp_xml'"
  $virsh dumpxml $1 > $tmp_xml

  if [ ! -z "$2" ] ; then # backup images

    declare -A processed

    for p in $src_paths
    do
      o=$(echo $p | sed -e "s|$images_dir/||g" | awk -F'/' '{ print $1 }'); [ -z $o ] && { echo "Cannot get $p"; exit 1; }
      d=$images_dir/$o; [ ! -z ${processed[$d]} ] && continue; processed[$d]=1

      if [ -d $d ] ; then
        run mkdir -p $tmp_dir/$o
        for c in $d/*
        do
          run $rsync $c $tmp_dir/$o
        done
        run $rsync $d $tmp_dir
      else
        run $rsync $d $tmp_dir
      fi
    done
  fi

  run 7z u $backup_dir/${1}.7z $tmp_dir

  [ -d "$tmp_dir" ] && run rm -r "$tmp_dir"
}

run_restore()
{
  dir_7z="${backup_dir}/${1}"
  src_7z="${dir_7z}.7z"
  xml_7z="${1}/${1}.xml"
  xml_vm="$backup_dir/$xml_7z"

  [ -f "$src_7z" ] || { echo "Backup file '$src_7z' does not exist"; exit 1; }
  [ -d "$dir_7z" ] && run rm -r "$dir_7z"

  run 7z x -o${backup_dir} $src_7z $xml_7z; [ -f $xml_vm ] || { echo "No $xml_vm found for $1"; exit 1; }

  if [ ! -z "$2" ] ; then # restore images
    run 7z x -o${images_dir} $src_7z -x!$xml_7z

    run find "$images_dir/${1}" -type d -exec chmod 0777 {} +
    run find "$images_dir/${1}" -type f -exec chmod 0666 {} +

    objs=$(\ls $images_dir/${1})

    run sudo find "$images_dir/${1}" -exec chown root:root {} +
    for obj in $objs
    do
      run sudo mv ${images_dir}/$1/$obj ${images_dir}
    done
    run sudo rmdir ${images_dir}/$1
  fi

  run sudo virsh undefine --nvram --tpm $1 | awk '!/^$/'
  run virsh --connect qemu:///system define $xml_vm | awk '!/^$/'
  # run sudo virsh define --file $xml_vm | awk '!/^$/'

  [ -d "$dir_7z" ] && run rm -r "$dir_7z"
}

start_stop()
{
  p_virsh="$1" # action to execute by virsh start or stop
  p_check="$2" # VM state to check
  p_egrep="$3" # VM state to egrep

  array=( $($virsh list --all | tail -n +3 | grep "$p_egrep" | awk '!/^$/ { printf "%s ", $2 }') )

  [ -z $array ] && { echo "No VM to $p_virsh"; exit 1; }

  for ((i = 0; i < ${#array[@]}; i++)); do
    printf "%s | %s | %s\n" "$i" "$p_egrep" "${array[i]}"
  done

  printf "choose number(s) to $p_virsh: "

  vm_list=$(get_vm_list)
  
  for vm in $vm_list
  do
    run_virsh $vm "$p_virsh" "$p_check" "$p_egrep"
  done
}

backup_restore()
{
  case $1 in 
    backup)
      vm_all=$($virsh list --all | tail -n +3 | awk '!/^$/')
      array=( $(echo "$vm_all" | awk '{ printf "%s ", $2 }') ); [ -z $array ] && { echo "No VM to $1"; exit 1; }
      echo "$vm_all" | awk '{printf "%s | %s %s | %s\n", NR-1, $3, $4, $2}'
      ;;
    restore)
      vm_all=$(find $backup_dir -mindepth 1 -maxdepth 1 | xargs basename -a 2>/dev/null | sed 's/\.[^.]*$//' | sort -u);
      array=( $vm_all ); [ -z $array ] && { echo "No VM to $1"; exit 1; }
      echo "$vm_all" | awk '{printf "%s | %s\n", NR-1, $1}'
      ;;
    *) return ;;
  esac

  printf "choose number(s) to $1: "

  vm_list=$(get_vm_list)

  for vm in $vm_list
  do
    if has_state $vm "$RUNNING"; then
      run_virsh $vm shutdown "$SHUTOFF" "$RUNNING"
    fi
  done

  for vm in $vm_list
  do
    if has_state $vm "$SHUTOFF"; then
      case $1 in 
        backup)  run_backup  $vm $2 ;;
        restore) run_restore $vm $2 ;;
      esac
    else
      echo "VM $vm is $RUNNING, skipping $1"
    fi
  done
}

case $1 in
  start)   s_cmd=start;    do_check="$RUNNING"; do_egrep="$SHUTOFF" ;;
  stop)    s_cmd=shutdown; do_check="$SHUTOFF"; do_egrep="$RUNNING" ;;
  backup)  b_cmd=$1; b_img="1" ;; # backup images and dump xml file
  restore) b_cmd=$1; b_img="1" ;; # restore images and define xml file
  dumpxml) b_cmd="backup"  ;;     # dump xml file
  xml)     b_cmd="restore" ;;     # connect to vm manager and define xml file
  *) echo "Unknown option $1"; exit 1 ;;
esac

mars_mount="$HOME/mars/Backup"
images_dir="$2"; [ -z $images_dir ] && images_dir="/var/lib/libvirt/images"
#backup_dir="$3"; [ -z $backup_dir ] && backup_dir="$mars_mount/$(hostname -s)/libvirt/backup"
backup_dir="$3"; [ -z $backup_dir ] && backup_dir="/shared/libvirt/backup"

if [ ! -z $b_cmd ] ; then

  if [[ $backup_dir =~ "$mars_mount/"* ]] ; then
    # mars should be mounted
    if ! findmnt $mars_mount > /dev/null; then
      echo "$mars_mount is not mounted"; exit 1
    fi
  fi

  [ ! -d $images_dir ] && { echo "Directory $images_dir does not exist"; exit 1; }
  [ ! -d $backup_dir ] && { echo "Directory $backup_dir does not exist"; exit 1; }

  backup_restore "$b_cmd" "$b_img"
else
  start_stop "$s_cmd" "$do_check" "$do_egrep"
fi

run $virsh list --all | awk '!/^$/'

exit 0

